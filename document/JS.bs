<pre class='metadata'>
Title: WebAssembly JS API
H1: WebAssembly 
Shortname: wasmjs
Status: CG-DRAFT
ED: https://webassembly.github.io/spec/JS.html
Editor: Andreas Rossberg
Repository: WebAssembly/spec
Abstract: This document provides an explicit JavaScript API for interacting with WebAssembly.
Markup Shorthands: css no, markdown yes
Ignored Terms: h1, h2, h3, h4, h5, h6, xmp
</pre>

<pre class='biblio'>
{
  "ECMASCRIPT": {
    "href": "https://tc39.github.io/ecma262",
    "title": "ECMAScript® 2018 Language Specification",
    "publisher": "ECMA TC39",
    "status": "Current Editor's Draft",
  },
  "WEBASSEMBLY": {
    "href": "https://webassembly.github.io/spec/",
    "title": "WebAssembly Specification",
    "publisher": "W3C WebAssembly Community Group",
    "status": "Draft",
  },
}
</pre>

This API is, initially, the only API for accessing WebAssembly [[WEBASSEMBLY]] from the Web Platform, through a bridge to explicitly construct modules from ECMAScript [[ECMASCRIPT]]. 

Issue: In future versions, WebAssembly
be loaded and run directly from an HTML `<script type='module'>` tag—and
any other Web API that loads ES6 modules via URL—as part of 
[ES6 Module integration](https://github.com/WebAssembly/design/issues/1087).)

Note: WebAssembly JS API declaration file for TypeScript can be found [here](https://github.com/01alchemist/webassembly-types/blob/master/webassembly.d.ts) which enable autocompletion and make TypeScript compiler happy.

The WebAssembly Object
======================

The following IDL uses a couple features which are not in IDL currently:
- To support constructors which are properties of the WebAssembly object, namespaces define interfacemembers. In the ECMAScript binding, these are writable, configurable, non-enumerable properties of the namespace. Inner interfaces inherit the exposure set of the outer namespace.
- The @@toStringTag of interfaces which are declared in a namespace is the name of the outer namespace, followed by `.`, followed by the name of the interface.
- The `[Nowrap]` extended attribute to an integer type throws a RangeError if the Number is greater than or less than the range which can be accurately represented by the type.  

<pre class="idl">
[Exposed=(Window,Worker)]
namespace WebAssembly {
  boolean validate(BufferSource bytes);
  Promise<Module> compile(BufferSource bytes);
  
  Promise<WebAssemblyInstantiatedSource> instantiate(
      BufferSource bytes, optional ImportObject importObject);

  Promise<WebAssembly.Instance> instantiate(
      Module moduleObject, optional ImportObject importObject);
};
</pre>


<pre class="idl">
dictionary WebAssemblyInstantiatedSource {
   required WebAssembly.Module module;
   required WebAssembly.Instance instance;
};

typedef (undefined or object) ImportObject;

enum ImportExportKind {
  "function",
  "table",
  "memory",
  "global"
};

dictionary ModuleExportDescriptor {
  required string name;
  required ImportExportKind kind;
};

dictionary ModuleImportDescriptor {
  required string module;
  required string name;
  required ImportExportKind kind;
};

partial namespace WebAssembly {
  [Contructor(BufferSource bytes)]
  interface Module {
    static sequence<ModuleExportDescriptor> exports(Module module);
    static sequence<ModuleImportDescriptor> imports(Module module);
   static sequence<ArrayBuffer> customSections(Module module, string sectionName);
 };
};

typedef (ExportedFunction or double or
         WebAssembly.Memory or WebAssembly.Table)
    WebAssemblyRuntimeValue;

typedef record<string, WebAssemblyRuntimeValue> InstanceExportMap;

typedef record<string, InstanceExportsMap> InstanceImportsMap;

partial namespace WebAssembly {
  [Contructor(Module module, optional InstanceImportsMap,  importObject)]
  interface Instance {
    readonly attribute InstanceExportsMap exports;
  };
};

dictionary MemoryDescriptor {
  required [Nowrap] unsigned long initial;
  optional [Nowrap] unsigned long maximum;
};

partial namespace WebAssembly {
  [Constructor(MemoryDecriptor descriptor)]
  interface Memory {
    void grow([Nowrap] unsigned long delta);
    readonly attribute ArrayBuffer buffer;
  };
};

enum TableKind {
  "anyfunc",
};

dictionary TableDescriptor {
  required TableKind element;
  required [Nowrap] unsigned long initial;
  optional [Nowrap] unsigned long maximum;
};

partial interface WebAssembly {
  [Constructor(TableDecriptor descriptor)]
  interface Memory {
    void grow([Nowrap] unsigned long delta);
    ExportedFunction get([Nowrap] unsigned long delta);
    set([Nowrap] unsigned long delta, ExportedFunction value);
    readonly attribute unsigned long length;
  };
};

[NoInterfaceObject]
interface ExportedFunction : Function { }
</pre>

Error objects
-------------

WebAssembly defines three Error classes. Analogous to DOMException, WebAssembly errors have the following custom bindings:
- Unlike normal interface types, the interface prototype object for DOMException must have as its [[Prototype]] the intrinsic object %ErrorPrototype%.
- If an implementation gives native Error objects special powers or nonstandard properties (such as a stack property), it should also expose those on DOMException instances.
- The constructor and properties of WebAssembly errors is as specified for [NativeErrors](https://tc39.github.io/ecma262/#sec-nativeerror-constructors).

<pre class='idl'>
partial interface WebAssembly {
  interface CompileError { }
  interface LinkError { }
  interface RuntimeError { }
}
</pre>

Error condition mappings to JavaScript
==============

Running WebAssembly programs encounter certain events which halt execution of the WebAssembly code.
WebAssembly code (currently)
has no way to catch these conditions and thus an exception will necessarily
propagate to the enclosing non-WebAssembly caller (either the browser or
JavaScript) where it is handled like a normal JavaScript exception.

If WebAssembly calls JavaScript via import and the JavaScript throws an
exception, the exception is propagated through the WebAssembly activation to the
enclosing caller.

Because JavaScript exceptions can be handled, and JavaScript can continue to
call WebAssembly exports after a trap has been handled, traps do not, in
general, prevent future execution.

Traps
-----

Whenever WebAssembly semantics specify a [trap](https://webassembly.github.io/spec/intro/overview.html#trap),
a `WebAssembly.RuntimeError` object is thrown to the enclosing JavaScript. 

Stack Overflow
---------

Whenever a [stack overflow](Semantics.md#stack-overflow) occurs in
WebAssembly code, the same class of exception is thrown as for a stack overflow in
JavaScript. The particular exception here is implementation-defined in both cases.

Out of Memory
---------

Whenever validation, compilation or instantiation run out of memory, the
same class of exception is thrown as for out of memory conditions in JavaScript.
The particular exception here is implementation-defined in both cases.
